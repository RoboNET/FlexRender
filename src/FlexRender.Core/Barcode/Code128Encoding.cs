using System.Text;

namespace FlexRender.Barcode.Code128;

/// <summary>
/// Shared Code 128B encoding logic.
/// </summary>
public static class Code128Encoding
{
    /// <summary>
    /// Code 128 encoding table for character set B (ASCII 32-127).
    /// </summary>
    private static readonly Dictionary<char, string> Code128BPatterns = new()
    {
        { ' ', "11011001100" }, { '!', "11001101100" }, { '"', "11001100110" },
        { '#', "10010011000" }, { '$', "10010001100" }, { '%', "10001001100" },
        { '&', "10011001000" }, { '\'', "10011000100" }, { '(', "10001100100" },
        { ')', "11001001000" }, { '*', "11001000100" }, { '+', "11000100100" },
        { ',', "10110011100" }, { '-', "10011011100" }, { '.', "10011001110" },
        { '/', "10111001100" }, { '0', "10011101100" }, { '1', "10011100110" },
        { '2', "11001110010" }, { '3', "11001011100" }, { '4', "11001001110" },
        { '5', "11011100100" }, { '6', "11001110100" }, { '7', "11101101110" },
        { '8', "11101001100" }, { '9', "11100101100" }, { ':', "11100100110" },
        { ';', "11101100100" }, { '<', "11100110100" }, { '=', "11100110010" },
        { '>', "11011011000" }, { '?', "11011000110" }, { '@', "11000110110" },
        { 'A', "10100011000" }, { 'B', "10001011000" }, { 'C', "10001000110" },
        { 'D', "10110001000" }, { 'E', "10001101000" }, { 'F', "10001100010" },
        { 'G', "11010001000" }, { 'H', "11000101000" }, { 'I', "11000100010" },
        { 'J', "10110111000" }, { 'K', "10110001110" }, { 'L', "10001101110" },
        { 'M', "10111011000" }, { 'N', "10111000110" }, { 'O', "10001110110" },
        { 'P', "11101110110" }, { 'Q', "11010001110" }, { 'R', "11000101110" },
        { 'S', "11011101000" }, { 'T', "11011100010" }, { 'U', "11011101110" },
        { 'V', "11101011000" }, { 'W', "11101000110" }, { 'X', "11100010110" },
        { 'Y', "11101101000" }, { 'Z', "11101100010" }, { '[', "11100011010" },
        { '\\', "11101111010" }, { ']', "11001000010" }, { '^', "11110001010" },
        { '_', "10100110000" }, { '`', "10100001100" }, { 'a', "10010110000" },
        { 'b', "10010000110" }, { 'c', "10000101100" }, { 'd', "10000100110" },
        { 'e', "10110010000" }, { 'f', "10110000100" }, { 'g', "10011010000" },
        { 'h', "10011000010" }, { 'i', "10000110100" }, { 'j', "10000110010" },
        { 'k', "11000010010" }, { 'l', "11001010000" }, { 'm', "11110111010" },
        { 'n', "11000010100" }, { 'o', "10001111010" }, { 'p', "10100111100" },
        { 'q', "10010111100" }, { 'r', "10010011110" }, { 's', "10111100100" },
        { 't', "10011110100" }, { 'u', "10011110010" }, { 'v', "11110100100" },
        { 'w', "11110010100" }, { 'x', "11110010010" }, { 'y', "11011011110" },
        { 'z', "11011110110" }, { '{', "11110110110" }, { '|', "10101111000" },
        { '}', "10100011110" }, { '~', "10001011110" }
    };

    /// <summary>
    /// Bar patterns indexed by Code 128 value (0-102) for checksum lookup.
    /// Covers all 103 possible checksum results including control codes
    /// (DEL, FNC1-FNC4, SHIFT, CODE A/B/C) that are not in the character dictionary.
    /// </summary>
    private static readonly string[] ChecksumPatterns =
    [
        "11011001100",  // 0  (SP)
        "11001101100",  // 1  (!)
        "11001100110",  // 2  (")
        "10010011000",  // 3  (#)
        "10010001100",  // 4  ($)
        "10001001100",  // 5  (%)
        "10011001000",  // 6  (&)
        "10011000100",  // 7  (')
        "10001100100",  // 8  (()
        "11001001000",  // 9  ())
        "11001000100",  // 10 (*)
        "11000100100",  // 11 (+)
        "10110011100",  // 12 (,)
        "10011011100",  // 13 (-)
        "10011001110",  // 14 (.)
        "10111001100",  // 15 (/)
        "10011101100",  // 16 (0)
        "10011100110",  // 17 (1)
        "11001110010",  // 18 (2)
        "11001011100",  // 19 (3)
        "11001001110",  // 20 (4)
        "11011100100",  // 21 (5)
        "11001110100",  // 22 (6)
        "11101101110",  // 23 (7)
        "11101001100",  // 24 (8)
        "11100101100",  // 25 (9)
        "11100100110",  // 26 (:)
        "11101100100",  // 27 (;)
        "11100110100",  // 28 (<)
        "11100110010",  // 29 (=)
        "11011011000",  // 30 (>)
        "11011000110",  // 31 (?)
        "11000110110",  // 32 (@)
        "10100011000",  // 33 (A)
        "10001011000",  // 34 (B)
        "10001000110",  // 35 (C)
        "10110001000",  // 36 (D)
        "10001101000",  // 37 (E)
        "10001100010",  // 38 (F)
        "11010001000",  // 39 (G)
        "11000101000",  // 40 (H)
        "11000100010",  // 41 (I)
        "10110111000",  // 42 (J)
        "10110001110",  // 43 (K)
        "10001101110",  // 44 (L)
        "10111011000",  // 45 (M)
        "10111000110",  // 46 (N)
        "10001110110",  // 47 (O)
        "11101110110",  // 48 (P)
        "11010001110",  // 49 (Q)
        "11000101110",  // 50 (R)
        "11011101000",  // 51 (S)
        "11011100010",  // 52 (T)
        "11011101110",  // 53 (U)
        "11101011000",  // 54 (V)
        "11101000110",  // 55 (W)
        "11100010110",  // 56 (X)
        "11101101000",  // 57 (Y)
        "11101100010",  // 58 (Z)
        "11100011010",  // 59 ([)
        "11101111010",  // 60 (\)
        "11001000010",  // 61 (])
        "11110001010",  // 62 (^)
        "10100110000",  // 63 (_)
        "10100001100",  // 64 (`)
        "10010110000",  // 65 (a)
        "10010000110",  // 66 (b)
        "10000101100",  // 67 (c)
        "10000100110",  // 68 (d)
        "10110010000",  // 69 (e)
        "10110000100",  // 70 (f)
        "10011010000",  // 71 (g)
        "10011000010",  // 72 (h)
        "10000110100",  // 73 (i)
        "10000110010",  // 74 (j)
        "11000010010",  // 75 (k)
        "11001010000",  // 76 (l)
        "11110111010",  // 77 (m)
        "11000010100",  // 78 (n)
        "10001111010",  // 79 (o)
        "10100111100",  // 80 (p)
        "10010111100",  // 81 (q)
        "10010011110",  // 82 (r)
        "10111100100",  // 83 (s)
        "10011110100",  // 84 (t)
        "10011110010",  // 85 (u)
        "11110100100",  // 86 (v)
        "11110010100",  // 87 (w)
        "11110010010",  // 88 (x)
        "11011011110",  // 89 (y)
        "11011110110",  // 90 (z)
        "11110110110",  // 91 ({)
        "10101111000",  // 92 (|)
        "10100011110",  // 93 (})
        "10001011110",  // 94 (~)
        "10111101000",  // 95 (DEL)
        "10111100010",  // 96 (FNC3)
        "11110101000",  // 97 (FNC2)
        "11110100010",  // 98 (SHIFT)
        "10111011110",  // 99 (CODE C)
        "10111101110",  // 100 (FNC4/CODE B)
        "11101011110",  // 101 (CODE A)
        "11010000100",  // 102 (FNC1)
    ];

    /// <summary>
    /// Code 128 start pattern for code set B.
    /// </summary>
    private const string Code128StartB = "11010010000";

    /// <summary>
    /// Code 128 stop pattern.
    /// </summary>
    private const string Code128Stop = "1100011101011";

    /// <summary>
    /// Builds the Code 128B barcode pattern for the provided data.
    /// </summary>
    /// <param name="data">Barcode data.</param>
    /// <returns>The encoded pattern string.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown when data contains unsupported characters for Code 128B.
    /// </exception>
    public static string BuildPattern(string data)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(data);

        var patternBuilder = new StringBuilder(Code128StartB);
        var checksum = 104; // Start B code value
        var position = 1;

        foreach (var c in data)
        {
            if (!Code128BPatterns.TryGetValue(c, out var charPattern))
            {
                throw new ArgumentException(
                    $"Character '{c}' (ASCII {(int)c}) is not supported in Code 128B. Supported range: ASCII 32-126.",
                    nameof(data));
            }

            patternBuilder.Append(charPattern);
            var codeValue = c - 32;
            checksum += codeValue * position;
            position++;
        }

        checksum %= 103;
        patternBuilder.Append(ChecksumPatterns[checksum]);

        patternBuilder.Append(Code128Stop);
        return patternBuilder.ToString();
    }
}
